{/*ReactPatterns.mdx*/}
import { Meta } from '@storybook/blocks'

<Meta title="Learning/03_Reactパターン" />

# Reactデザインパターンとアーキテクチャ

本プロジェクトで採用している設計パターンを、一般的なソフトウェアデザインパターンの文脈で解説します。

## 1. 制御の反転 (Inversion of Control)

コンポーネントの再利用性を高めるため、依存関係を外部から注入する **IoC** の原則を適用します。Reactにおいてこれは **Composition (合成)** と **Props** によって実現されます。

### Render Props / Function as Child

具体的なレンダリングロジックを親コンポーネントに委譲するパターンです。

```typescript
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode; // Strategy Pattern
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map(renderItem)}</ul>;
}
```

## 2. メモ化戦略 (Memoization Strategy)

メモ化は **計算量 (Time Complexity)** と **メモリ使用量 (Space Complexity)** のトレードオフです。

- **useMemo**: 計算結果のキャッシュ。$O(N)$ の計算を $O(1)$ に短縮しますが、キャッシュのためのメモリを消費します。
- **useCallback**: 関数インスタンスの同一性 (Referential Equality) を保持します。これは子コンポーネントの `React.memo` による不要な再レンダリングを防ぐために必須です。

$$ Cost(ReRender) > Cost(Memoization) $$

この不等式が成立する場合にのみ、メモ化を適用すべきです。安易なメモ化はオーバーヘッドを招きます。

## 3. Flux アーキテクチャと Reducer

`useReducer` フックは、Facebookが提唱した **Flux** アーキテクチャ（単方向データフロー）の思想を受け継いでいます。これは **Command Pattern** の一種と見なすことができます。

- **State**: SSOT (Single Source of Truth)
- **Action**: 意図を表すイベントオブジェクト
- **Reducer**: 純粋関数 $f(State, Action) \rightarrow NewState$ (状態遷移関数)

```typescript
type FlightPlanState = {
  waypoints: Array<[number, number]>
  isValid: boolean
}

// Action = Command
type Action = 
  | { type: 'ADD_WAYPOINT'; coord: [number, number] }
  | { type: 'RESET' }

// Reducer = State Machine Transition Logic
function flightPlanReducer(state: FlightPlanState, action: Action): FlightPlanState {
  switch (action.type) {
    case 'ADD_WAYPOINT':
      // Immutability の保持（新しいオブジェクトを生成して返す）
      return { ...state, waypoints: [...state.waypoints, action.coord] }
    case 'RESET':
      return { waypoints: [], isValid: false }
    default:
      return state
  }
}
```

## 4. Higher-Order Components (HOC) と Hooks

かつては Mixin パターンやDecorator パターンとして HOC が使用されましたが、現在は **Custom Hooks** がロジックの再利用の主流です。これは **AOP (Aspect Oriented Programming)** のような「横断的関心事（Cross-Cutting Concerns）」の分離を可能にします。

- 通信ロジック
- エラーハンドリング
- サブスクリプション管理

これらをコンポーネントのビューロジックから分離し、フックとしてカプセル化します。

## 5. Context による依存性の注入 (Dependency Injection)

`useContext` は、コンポーネントツリーの深層に値を配送するメカニズムですが、アーキテクチャ的には **Service Locator** や **Dependency Injection** コンテナの役割を果たします。グローバルな状態管理だけでなく、機能モジュールの提供にも利用されます。

```typescript
const MapContext = createContext<MapService | null>(null);

export const MapProvider = ({ children }) => {
  // Service Instance の生成
  const mapService = useMapService();
  return (
    <MapContext.Provider value={mapService}>
      {children}
    </MapContext.Provider>
  )
}
```
