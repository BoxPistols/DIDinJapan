{/* DataImport.mdx */}
import { Meta } from '@storybook/blocks'

<Meta title="Learning/09_データインポートプロセス" />

# データパイプラインとETLアーキテクチャ

外部データソース（GSI等）をアプリケーションに取り込むプロセスは、**ETL (Extract, Transform, Load)** パターンに従って設計されています。

## 1. Extract (抽出): 非同期データ取得と並行制御

データの取得フェーズでは、JavaScriptの **Event Loop** と **Microtask Queue** の特性を理解した並行処理制御が不可欠です。

### Promise Pool Pattern

大量のタイルリクエストを同時に発行するとネットワーク帯域やブラウザのコネクションプールを枯渇させます。**Semaphore (セマフォ)** を用いた並行数制御（Promise Pool）を実装します。

```typescript
async function fetchAllTiles(urls: string[], concurrency: number) {
  const results = [];
  const executing = new Set();
  
  for (const url of urls) {
    const p = fetch(url).then(r => r.json());
    results.push(p);
    
    // 実行中セットに追加し、完了時に削除
    const e = p.then(() => executing.delete(e));
    executing.add(e);
    
    // 並行数が上限に達したら、どれか1つが終わるのを待つ
    if (executing.size >= concurrency) {
      await Promise.race(executing);
    }
  }
  return Promise.all(results);
}
```

## 2. Transform (変換): データ正規化とサニタイズ

GeoJSONデータは外部入力であるため、信頼せずバリデーションと正規化（Normalization）を行います。これは **Adapter Pattern** の役割も果たします。

### ジオメトリの正規化

- **Winding Order**: ポリゴンの頂点順序（時計回り/反時計回り）を修正。
- **Coordinates**: 文字列として渡された数値を `number` 型にキャスト。
- **Properties**: 欠損値の補完（Default Values）。

```typescript
type RawFeature = { geometry: any; properties: any };
type NormalizedFeature = Feature<Geometry, GeoJsonProperties>;

function normalizeFeature(raw: RawFeature): NormalizedFeature {
  // Defensive Copying
  const geometry = { ...raw.geometry };
  
  // Coordinate Sanitization
  if (geometry.type === 'Point') {
    geometry.coordinates = geometry.coordinates.map(Number);
  }
  
  return {
    type: 'Feature',
    geometry,
    properties: sanitizeProperties(raw.properties)
  };
}
```

## 3. Load (ロード): 状態管理と副作用

変換されたデータは、Reactの `Status` や MapLibre GL の `Source` にロードされます。ここでは **Immutability (不変性)** の維持が重要です。

`map.addSource()` や `map.setData()` は命令的な副作用ですが、Reactのライフサイクル内で宣言的に管理するために `useEffect` でラップし、データの同一性チェック（Deep Comparison または Reference Check）を行って不要な更新を防ぎます。

## 4. バッチ処理とメインスレッドの解放

数万点のポイントデータをループ処理する場合、メインスレッドをブロックし UI がフリーズ (Jank) する原因となります。**Chunking (チャンク化)** と `requestIdleCallback` または `setTimeout` を用いて処理を分割します。

```typescript
function processLargeDataset(data: any[], type: string) {
  let index = 0;
  function processChunk() {
    const start = performance.now();
    while (index < data.length && performance.now() - start < 16) { // 16ms (1 frame) 以内で処理
      processItem(data[index]);
      index++;
    }
    
    if (index < data.length) {
      // 次のフレームへ持ち越し
      requestAnimationFrame(processChunk); 
    } else {
      console.log('Done');
    }
  }
  processChunk();
}
```

## 5. ベストプラクティス：ロバストネス原則

> "Be conservative in what you do, be liberal in what you accept from others." (Postel's Law)

データインポートにおいては、「入力データは常に不正である可能性がある」という前提（**Defensive Programming**）に立ち、例外処理ではなく、グレースフルなデグレード（部分的に読み込めなくても全体はクラッシュさせない）を実装します。

